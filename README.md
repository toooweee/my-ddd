# DDD

### Поток может выглядеть так:

1. `Запрос/событие` отправляется в **`контроллер`** используя DTO
2. **`Контроллер`** парсит DTO и отправляет его дальше в **`Сервис приложения`**
3. **`Сервис приложения`** обрабатывает команду/запрос. Выполняет бизнес-логику, используя **`Доменные сервисы`** и **`сущности/агрегаты`** и использует **`Инфраструктурный слой`** через **`Порты` (interfaces)**
4. **`Инфраструктурный слой`** преобразует данные в необходимый ему формат, извлекает или сохраняет данные в бд, использует адаптеры для других операций IO, преобразует данные обратно в формат предметной области и возвращает их в **`Сервис приложения`**
5. Как только **`Сервис приложения`** закончит, он вернет данные в **`Контроллер`**
6. **`Контроллер`** вернет данные обратно пользователю

### Структура

NestJS предлагает модульную структуру, и здесь, точно также можно следовать этому. Каждый модуль будет отражать доменную область. Каждый модуль нужно пытаться сделать независимым, и минимизировать взаимодействие между другими модулями

#### Как избежать зависимостей между модулями:
1. Переносите общую логику в отдельные файлы, и использовать их, а не зависеть друг от друга
2. Модули могут взаимодействовать через посредника или публичный интерфейс, инкаспулируя логику, и предоставляя только нужное.
3. Можно использовать сообщения и подписки, чтобы реагировать на уведомления

Следуя принципам выше, можно добиться слабой связности, упрощения рефакторинга, и по итогу в будущем можно будет легко разбить каждый модуль на отдельный микросервис.

## Application core

### Доменный слой:

1. Сущности
2. Агрегаты
3. Доменные сервисы
4. Объекты-значения
5. Доменные ошибки

Хранит чистую бизнес-логику, безо всяких зависимостей (без Prisma, NestJS и тп)

### Слой приложения

1. Сервисы приложения
2. Команды и запросы
3. Порты

Здесь наоборот, никакой доменной бизнес логики.

### Application layer

-----

##### Application services
Сервисы приложения, также называемые `use-cases`, `interactors`, используются для организации действий, необходимых для выполнения команд, заданных клиентом:

1. Обычно используются для организации взаимодействия внешнего мира с вашим приложением и выполнения задач, требуемых конечным пользователям.
2. Не содержит бизнес-логики, зависящей от предметной области.
3. 