# DDD

### Поток может выглядеть так:

1. `Запрос/событие` отправляется в **`контроллер`** 
2. **`Контроллер`** парсит DTO и отправляет его дальше в **`Сервис приложения`**
3. **`Сервис приложения`** обрабатывает команду/запрос. Выполняет бизнес-логику, используя **`Доменные сервисы`** и **`сущности/агрегаты`** и использует **`Инфраструктурный слой`** через **`Порты` (interfaces)**
4. **`Инфраструктурный слой`** преобразует данные в необходимый ему формат, извлекает или сохраняет данные в бд, использует адаптеры для других операций IO, преобразует данные обратно в формат предметной области и возвращает их в **`Сервис приложения`**
5. Как только **`Сервис приложения`** закончит, он вернет данные в **`Контроллер`**
6. **`Контроллер`** вернет данные обратно пользователю

### Структура

NestJS предлагает модульную структуру, и здесь, точно также можно следовать этому. Каждый модуль будет отражать доменную область. Каждый модуль нужно пытаться сделать независимым, и минимизировать взаимодействие между другими модулями

#### Как избежать зависимостей между модулями:
1. Переносите общую логику в отдельные файлы, и использовать их, а не зависеть друг от друга
2. Модули могут взаимодействовать через посредника или публичный интерфейс, инкаспулируя логику, и предоставляя только нужное.
3. Можно использовать сообщения и подписки, чтобы реагировать на уведомления

Следуя принципам выше, можно добиться слабой связности, упрощения рефакторинга, и по итогу в будущем можно будет легко разбить каждый модуль на отдельный микросервис.

## Application core

-----

### Доменный слой:

1. Сущности
2. Агрегаты
3. Доменные сервисы
4. Объекты-значения
5. Доменные ошибки

Хранит чистую бизнес-логику, безо всяких зависимостей (без Prisma, NestJS и тп)

### Слой приложения

1. Сервисы приложения
2. Команды и запросы
3. Порты

Здесь наоборот, никакой доменной бизнес логики.

### Application layer

-----

##### Application services
Сервисы приложения, также называемые `use-cases`, `interactors`, используются для организации действий, необходимых для выполнения команд, заданных клиентом:

1. Обычно используются для организации взаимодействия внешнего мира с вашим приложением и выполнения задач, требуемых конечным пользователям. Это как админ на ресепшене, его работа в том, чтобы направлять, а не делать то, что хотят посетители.
2. Не содержит бизнес-логики, зависящей от предметной области. Это скелет без костей.
3. Работают с простыми, скалярными типами, преобразуя их в типы домена.
4. Используют порты, чтобы объявлять зависимости от адаптеров, нужных для выполнения доменной логики. Порты - это как сервис говорит, я хочу попить (интерфейс), а не мне нужна артезианская вода со святого источника, что позволяет не зависеть от деталей (БД, API).
5. Загружают доменные сущности/аггрегаты из БД или внешних сервисов через порты, интерфейсы, с конкретными реализациям, внедренными с помощью DI. Сервис берет данные не напрямую из хранилища, а через интерфейс.
6. Выполняет доменную логику на этих сущностях/агрегатах вызывая их методы. Получив объекты домена, он просто вызывает их методы, где и содержится вся бизнес-логика. Он не думает, а просто делегирует.